---
title: "Rustã®Serdeã‚¯ãƒ¬ãƒ¼ãƒˆã§å…±ç”¨ä½“ã‚’æ‰±ã†"
emoji: "ğŸ“˜"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust"]
published: false
---

# æ¦‚è¦

ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ãª Json ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ‰±ã„ãŸã„ã¨ã—ã¾ã™ã€‚

```json:data.json
[
    { "x" : 100 },
    { "x": "abc" }
]
```

Rust ã§ã“ã® Json ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º/ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã™ã‚‹ã«ã‚ãŸã£ã¦ `x` ã®å€¤ã¯æ–‡å­—åˆ—å‹åˆã¯æ•°å€¤å‹ã§ã‚ã‚‹ã“ã¨ã‚’è¡¨ç¾ã™ã‚‹æ–¹æ³•ã‚’èª¿ã¹ã¾ã—ãŸã€‚

# æ–¹æ³• 1: `Value` å‹ã‚’ä½¿ã†

ãã‚Œãã‚Œã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ã‚¯ãƒ¬ãƒ¼ãƒˆã«ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªå‹ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚

- `serde_json::Value`
- `serde_yml::Value`
- `toml::Value`

ã“ã‚Œã¯ã„ã‚ã‚†ã‚‹ `Any` å‹ã§ã‚ã‚Šã€ãã‚Œãã‚Œã®ãƒ‡ãƒ¼ã‚¿ã§è¡¨ç¾ã§ãã‚‹å‹ã‚’ã„ãšã‚Œã§ã‚‚æ ¼ç´ã§ãã‚‹å‹ã¨ãªã£ã¦ã„ã¾ã™ã€‚

```rust:main.rs
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let json = r#"
        [
            { "x": 100 },
            { "x": "abc" }
        ]
    "#;
    // ã“ã“ã§ã¯ã€serde_yaml::Valueã‚„toml::Valueå‹ã§ã‚‚è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
    let v: serde_json::Value = serde_json::from_str(json)?;
    dbg!(v);

    Ok(())
}
```

ãŸã ã—ã€ã“ã®æ–¹æ³•ã¯å‹•çš„å‹ã®è¨€èªã¨ json ã®æ‰±ã„ã¨åŒç­‰ã§ã‚ã‚Šã€ãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã†ãŸã‚ã«ã¯ä¸­èº«ã‚’è§£æã™ã‚‹å¿…è¦ãŒã‚ã‚Šé¢å€’ã§ã™ã—å¯èª­æ€§ã‚‚è‰¯ãã‚ã‚Šã¾ã›ã‚“ã€‚
æŠ˜è§’ Rust ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã§å‹ã§æ‰±ã„ãŸã„ã§ã™ã€‚

```rust:main.rs
fn main() -> Result<(), Box<dyn std::error::Error>> {
    use serde_json::Value;

    let json = r#"
        [
            { "x": 100 },
            { "x": "abc" }
        ]
    "#;

    let data: Value = serde_json::from_str(json)?;

    match data {
        Value::Array(arr) => {
            for item in arr {
                match item {
                    Value::Object(item) => match item.get("x") {
                        Some(Value::Number(x)) => println!("x is Number({})", x),
                        Some(Value::String(x)) => println!("x is String({})", x),
                        _ => unreachable!(),
                    },
                    _ => unreachable!(),
                }
            }
        }
        _ => unreachable!(),
    }

    Ok(())
}
```

# æ–¹æ³• 2: å¯¾è±¡ã®å€¤ä»¥å¤–ã‚’æ§‹é€ ä½“ã§å®šç¾©ã™ã‚‹

ä»¥ä¸‹ã®ã‚ˆã†ã«å‹ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ Rust ã®å‹ã§ãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚

```rust:main.rs
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Data(pub Vec<Item>);

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Item {
    pub x: serde_json::Value,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let json = r#"
        [
            { "x": 100 },
            { "x": "abc" }
        ]
    "#;

    // å‹æŒ‡å®šã¯ Vec<Item> ã§ã‚‚ã‚ˆã„
    let data: Data = serde_json::from_str(json)?;

    for item in data.0 {
        use serde_json::Value;

        match item.x {
            Value::Number(x) => println!("x is Number({})", x),
            Value::String(x) => println!("x is String({})", x),
            _ => unreachable!(),
        }
    }

    Ok(())
}

```

ã“ã‚Œã¯ `x` ã®ã¿ `serde_json::Value` å‹ã§å®šç¾©ã—ã¦ãŠã‚Šã€ `x` å€¤ã‚’ä»»æ„ã®å€¤ãŒå…¥ã‚‹ã“ã¨ã‚’è€ƒæ…®ã—ãŸã„ã«ã¦æœ‰ç”¨ã§ã™ã€‚

# æ–¹æ³• 3: åˆ—æŒ™å‹ã‚’ä½¿ã†

`x` å€¤ã‚’æ–‡å­—åˆ—ã‹æ•°å€¤ã®ã¿ã§æ‰±ã„ãŸã„å ´åˆã€`enum` ã§å®šç¾©ã§ãã¾ã™ã€‚

```rust:main.rs
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Item {
    pub x: X,
}
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum X {
    String(String),
    Number(i64),
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let json = r#"
        [
            { "x": 100 },
            { "x": "abc" }
        ]
    "#;

    // å‹æŒ‡å®šã¯ Vec<Item> ã§ã‚‚ã‚ˆã„
    let data: Data = serde_json::from_str(json)?;
    for item in data.0 {
        match item.x {
            X::Number(x) => println!("x is Number({})", x),
            X::String(x) => println!("x is String({})", x),
        }
    }

    Ok(())
}

```

ãƒã‚¤ãƒ³ãƒˆã¯ `X` å‹ã®å±æ€§ `#[serde(untagged)]` ã§ã“ã‚Œã‚’æŒ‡å®šã—ãªã„ã¨ã€Json ã‚’ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã™ã‚‹éš›ã«ã€ä»¥ä¸‹ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¦æ±‚ã•ã‚Œã¾ã™ã€‚

```json:data.json
[
  {
    "x": { "Number": 100 }
  },
  {
    "x": { "String": "abc" }
  }
]
```

ã“ã‚Œã¯ã‚¿ã‚°ä»˜ãå…±ç”¨ä½“ã¨å‘¼ã°ã‚Œã‚‹ã‚‚ã®ã§ãã®ã¾ã¾ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º/ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã™ã‚‹ã“ã¨ãŒæœ‰ç”¨ãªå ´é¢ã‚‚å­˜åœ¨ã—ã¾ã™ã€‚(åˆ¥ç¨®ã® `object` å‹ ã‚’æ‰±ã„ãŸã„æ™‚ãªã©)

## ã‚¿ã‚°ä»˜ãå…±ç”¨ä½“

ã‚¿ã‚°ã®ã¤ã‘æ–¹ã‚’ä»¥ä¸‹ã«å¤‰æ›´ã—ã¦ã¿ã¾ã™ã€‚

```json:data.json
[
    { "type": "number", "x" : 100 },
    { "type": "string",  "x": "abc" }
]
```

```rust:main.rs
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Data(pub Vec<Item>);

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum Item {
    #[serde(rename = "number")]
    Number { x: i64 },
    #[serde(rename = "string")]
    String { x: String },
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let json = r#"
        [
            { "type": "string", "x": "abc" },
            { "type": "number", "x": 100 }
        ]
    "#;

    let data: Data = serde_json::from_str(json)?;
    for item in data.0 {
        match item {
            Item::Number { x } => println!("x is Number({})", x),
            Item::String { x } => println!("x is String({})", x),
        }
    }

    Ok(())
}
```

`#[serde(tag = "type")]` ã§ã‚¿ã‚°åã®æŒ‡å®šã€`#[serde(rename = "...")]` ã§ã‚¿ã‚°ã®å€¤ã®æŒ‡å®šãŒã§ãã¾ã™ã€‚

# å‚è€ƒ

https://serde.rs/

https://serde.rs/enum-representations.html
